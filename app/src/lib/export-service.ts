import JSZip from 'jszip';
import { Project, Tool, AuthScheme } from '../types';
import { getCircularReplacer } from './project-service';

export async function generateMCPProjectZip(project: Project): Promise<Blob> {
  const zip = new JSZip();

  // Root files
  zip.file('package.json', generatePackageJson(project));
  zip.file('tsconfig.json', generateTsConfig());
  zip.file('.gitignore', generateGitIgnore());
  zip.file('README.md', generateReadme(project));
  zip.file('.env.example', generateEnvExample(project));

  // Source files
  const src = zip.folder('src');
  if (src) {
    src.file('index.ts', generateServerCode(project));
  }

  return await zip.generateAsync({ type: 'blob' });
}

function generatePackageJson(project: Project): string {
  const config = {
    name: project.name.toLowerCase().replace(/\s+/g, '-'),
    version: project.version,
    description: "MCP Server generated by MCP Builder",
    type: "module",
    scripts: {
      "build": "tsc",
      "start": "node dist/index.js",
      "dev": "ts-node src/index.ts"
    },
    dependencies: {
      "@modelcontextprotocol/sdk": "^0.6.0",
      "axios": "^1.6.0",
      "dotenv": "^16.3.0",
      "open": "^10.0.0"
    },
    devDependencies: {
      "@types/node": "^20.0.0",
      "typescript": "^5.0.0",
      "ts-node": "^10.9.0"
    }
  };
  return JSON.stringify(config, null, 2);
}

function generateTsConfig(): string {
  const config = {
    compilerOptions: {
      target: "ES2022",
      module: "Node16",
      moduleResolution: "Node16",
      outDir: "./dist",
      rootDir: "./src",
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true
    },
    include: ["src/**/*"],
    exclude: ["node_modules"]
    
  };
  return JSON.stringify(config, null, 2);
}

function generateGitIgnore(): string {
  return `node_modules
dist
.env
.DS_Store
`;
}

function generateReadme(project: Project): string {
  const usedAuth = getUsedAuthSchemes(project);
  const envVars: Record<string, string> = {};
  
  usedAuth.forEach(auth => {
    if (auth.type === 'apiKey') {
      envVars[`${auth.name.toUpperCase().replace(/\s+/g, '_')}_KEY`] = "your-api-key";
    } else if (auth.type === 'oauth2') {
      const prefix = auth.name.toUpperCase().replace(/\s+/g, '_');
      envVars[`${prefix}_CLIENT_ID`] = "your-client-id";
      envVars[`${prefix}_CLIENT_SECRET`] = "your-client-secret";
      if (auth.config.oauthFlow !== 'interactive') {
          envVars[`${prefix}_ACCESS_TOKEN`] = "your-access-token";
          envVars[`${prefix}_REFRESH_TOKEN`] = "your-refresh-token";
      }
    } else if (auth.type === 'bearer') {
      envVars[`${auth.name.toUpperCase().replace(/\s+/g, '_')}_TOKEN`] = "your-token";
    } else if (auth.type === 'basic') {
      envVars[`${auth.name.toUpperCase().replace(/\s+/g, '_')}_USERNAME`] = "your-username";
      envVars[`${auth.name.toUpperCase().replace(/\s+/g, '_')}_PASSWORD`] = "your-password";
    }
  });

  const envJson = Object.keys(envVars).length > 0 
      ? `"env": ${JSON.stringify(envVars, null, 6).replace(/\n/g, '\n      ')}`
      : '// "env": {}';

  return `# ${project.name}

MCP Server generated by MCP Builder.

## Setup

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Configure environment variables:
   Copy \`.env.example\` to \`.env\` and fill in the required values.

3. Build:
   \`\`\`bash
   npm run build
   \`\`\`

4. Run:
   \`\`\`bash
   npm start
   \`\`\`

## Configuration for Claude Desktop

Add this to your \`claude_desktop_config.json\`:

\`\`\`json
{
  "mcpServers": {
    "${project.name.toLowerCase().replace(/\s+/g, '-')}": {
      "command": "node",
      "args": ["${process.platform === 'win32' ? '%APPDATA%/npm/node_modules/...' : '/path/to/'}dist/index.js"],
      ${envJson}
    }
  }
}
\`\`\`
`;
}

function generateEnvExample(project: Project): string {
  // Collect all unique auth env vars needed
  const envVars = new Set<string>();
  const usedAuth = getUsedAuthSchemes(project);
  
  // Add global auth env vars if any
  usedAuth.forEach(auth => {
    if (auth.type === 'apiKey') {
      envVars.add(`${auth.name.toUpperCase().replace(/\s+/g, '_')}_KEY=`);
    } else if (auth.type === 'oauth2') {
      const prefix = auth.name.toUpperCase().replace(/\s+/g, '_');
      envVars.add(`${prefix}_CLIENT_ID=`);
      envVars.add(`${prefix}_CLIENT_SECRET=`);
      
      if (auth.config.oauthFlow !== 'interactive') {
          envVars.add(`${prefix}_ACCESS_TOKEN=`);
          envVars.add(`${prefix}_REFRESH_TOKEN=`);
      }
    } else if (auth.type === 'bearer') {
      envVars.add(`${auth.name.toUpperCase().replace(/\s+/g, '_')}_TOKEN=`);
    } else if (auth.type === 'basic') {
      envVars.add(`${auth.name.toUpperCase().replace(/\s+/g, '_')}_USERNAME=`);
      envVars.add(`${auth.name.toUpperCase().replace(/\s+/g, '_')}_PASSWORD=`);
    }
  });

  return Array.from(envVars).join('\n');
}

function generateServerCode(project: Project): string {
  const usedAuth = getUsedAuthSchemes(project);
  // Check if we need interactive auth imports
  const hasInteractive = usedAuth.some(a => a.type === 'oauth2' && a.config.oauthFlow === 'interactive');
  
  // 1. Generate Standard Tools Definitions
  const defaultSchema = { type: "object", properties: {}, required: [] };
  const standardTools = project.tools
    .filter(t => t.enabled)
    .map(tool => {
      // Ensure inputSchema is always a valid object schema - Claude requires this
      const schema = tool.requestSchema && typeof tool.requestSchema === 'object' && Object.keys(tool.requestSchema).length > 0
        ? tool.requestSchema
        : defaultSchema;
      return `
      {
        name: "${tool.name}",
        description: ${JSON.stringify(tool.description)},
        inputSchema: ${JSON.stringify(schema, getCircularReplacer())}
      }`;
    });

  // 2. Generate Interactive Auth Tools Definitions
  const authTools = usedAuth
    .filter(a => a.type === 'oauth2' && a.config.oauthFlow === 'interactive')
    .map(auth => `
      {
        name: "login_${auth.name.toLowerCase().replace(/\s+/g, '_')}",
        description: "Interactive login for ${auth.name}",
        inputSchema: {
          type: "object",
          properties: {},
          required: []
        }
      }`);

  // 3. Combine all tool definitions
  const allToolDefinitions = [...standardTools, ...authTools].join(',');

  return `import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import axios from "axios";
import dotenv from "dotenv";
${hasInteractive ? `import open from "open";
import http from "http";
import { URL } from "url";` : ''}

dotenv.config();

const server = new Server(
  {
    name: "${project.name}",
    version: "${project.version}",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// In-memory token store for interactive auth
const globalTokens: Record<string, string> = {};

// Helper function to handle API requests with configurable token refresh
async function makeRequest(config: any, authConfig?: any) {
  try {
    const response = await axios(config);
    return response.data;
  } catch (error: any) {
    if (axios.isAxiosError(error) && error.response?.status === 401 && authConfig?.refreshToken) {
       try {
         const tokenParams: Record<string, string> = {
           grant_type: 'refresh_token',
           refresh_token: authConfig.refreshToken,
           ...(authConfig.tokenAuthMethod !== 'header' ? {
             client_id: authConfig.clientId,
             client_secret: authConfig.clientSecret
           } : {}),
           ...(authConfig.additionalTokenParams || {})
         };
         
         const refreshConfig: any = {
           method: 'POST',
           url: authConfig.tokenUrl,
           headers: {
             'Content-Type': authConfig.tokenRequestFormat === 'json' 
               ? 'application/json' 
               : 'application/x-www-form-urlencoded',
             ...(authConfig.tokenAuthMethod === 'header' ? {
               'Authorization': 'Basic ' + Buffer.from(authConfig.clientId + ':' + authConfig.clientSecret).toString('base64')
             } : {})
           },
           data: authConfig.tokenRequestFormat === 'json' 
             ? tokenParams 
             : new URLSearchParams(tokenParams).toString()
         };
         
         const tokenResponse = await axios(refreshConfig);
         const newToken = tokenResponse.data.access_token || tokenResponse.data.id_token;
         if (newToken) {
             // Update global store if using that
             if (authConfig.authId) {
                 globalTokens[authConfig.authId] = newToken;
             }
             
             config.headers['Authorization'] = \`Bearer \${newToken}\`;
             const retryResponse = await axios(config);
             return retryResponse.data;
         }
       } catch (refreshError) {
         console.error("Token refresh failed", refreshError);
       }
    }

    if (axios.isAxiosError(error)) {
      throw new Error(\`API request failed: \${error.message}. \${JSON.stringify(error.response?.data || {})}\`);
    }
    throw error;
  }
}

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      ${allToolDefinitions}
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  // Handle Interactive Login Tools
  ${usedAuth.filter(a => a.type === 'oauth2' && a.config.oauthFlow === 'interactive').map(auth => {
      const prefix = auth.name.toUpperCase().replace(/\s+/g, '_');
      const callbackPort = auth.config.callbackPort || 3000;
      const responseType = auth.config.responseType || 'code';
      const grantType = auth.config.grantType || 'authorization_code';
      const tokenRequestFormat = auth.config.tokenRequestFormat || 'form';
      const tokenAuthMethod = auth.config.tokenAuthMethod || 'body';
      const usePkce = auth.config.usePkce || false;
      const additionalAuthParams = auth.config.additionalAuthParams || {};
      const additionalTokenParams = auth.config.additionalTokenParams || {};
      
      return `
  if (name === "login_${auth.name.toLowerCase().replace(/\s+/g, '_')}") {
      const clientId = process.env.${prefix}_CLIENT_ID;
      const clientSecret = process.env.${prefix}_CLIENT_SECRET;
      const authUrl = "${auth.config.authUrl}";
      const tokenUrl = "${auth.config.tokenUrl}";
      const redirectUri = "http://localhost:${callbackPort}/callback";
      
      if (!clientId || !clientSecret) {
          throw new Error("Missing Client ID or Secret in environment");
      }

      ${usePkce ? `
      // Generate PKCE code verifier and challenge
      const crypto = await import('crypto');
      const codeVerifier = crypto.randomBytes(32).toString('base64url');
      const codeChallenge = crypto.createHash('sha256').update(codeVerifier).digest('base64url');
      ` : ''}

      // Generate state for CSRF protection
      const state = Math.random().toString(36).substring(2, 15);

      // 1. Start Server
      const p = new Promise<string>((resolve, reject) => {
          const s = http.createServer(async (req, res) => {
              try {
                  const url = new URL(req.url!, "http://localhost:${callbackPort}");
                  const code = url.searchParams.get("code");
                  const returnedState = url.searchParams.get("state");
                  const idToken = url.searchParams.get("id_token");
                  const accessToken = url.searchParams.get("access_token");
                  
                  // Validate state
                  if (returnedState !== state) {
                      res.end("State mismatch - possible CSRF attack");
                      s.close();
                      reject(new Error("State mismatch"));
                      return;
                  }
                  
                  // Handle implicit flow tokens (token or id_token in URL)
                  if (accessToken && !code) {
                      res.end("Login successful! You can close this window.");
                      s.close();
                      resolve(accessToken);
                      return;
                  }
                  
                  if (code) {
                      res.end("Login successful! You can close this window.");
                      s.close();
                      
                      // 2. Exchange Code for Token
                      try {
                        const tokenParams: Record<string, string> = {
                            grant_type: '${grantType}',
                            code,
                            redirect_uri: redirectUri,
                            ${tokenAuthMethod === 'body' ? `client_id: clientId!,
                            client_secret: clientSecret!,` : ''}
                            ${usePkce ? 'code_verifier: codeVerifier,' : ''}
                            ...${JSON.stringify(additionalTokenParams)}
                        };
                        
                        const tokenConfig: any = {
                            method: 'POST',
                            url: tokenUrl,
                            ${tokenAuthMethod === 'header' ? `headers: {
                                'Authorization': 'Basic ' + Buffer.from(clientId + ':' + clientSecret).toString('base64'),
                                'Content-Type': '${tokenRequestFormat === 'form' ? 'application/x-www-form-urlencoded' : 'application/json'}'
                            },` : `headers: {
                                'Content-Type': '${tokenRequestFormat === 'form' ? 'application/x-www-form-urlencoded' : 'application/json'}'
                            },`}
                            ${tokenRequestFormat === 'form' ? 'data: new URLSearchParams(tokenParams).toString()' : 'data: tokenParams'}
                        };
                        
                        const tokenRes = await axios(tokenConfig);
                        const token = tokenRes.data.access_token || tokenRes.data.id_token;
                        if (token) {
                            resolve(token);
                        } else {
                            reject(new Error("No access_token or id_token in response: " + JSON.stringify(tokenRes.data)));
                        }
                      } catch (e: any) {
                        reject(new Error("Failed to exchange token: " + e.message + " " + JSON.stringify(e.response?.data || {})));
                      }
                  } else if (!accessToken) {
                      res.end("No code or token found in callback");
                  }
              } catch (e) {
                  res.end("Error");
                  reject(e);
              }
          });
          
          s.listen(${callbackPort});
          
          // 3. Open Browser
          const responseType = "${responseType}";
          const scopeStr = "${(auth.config.scopes || []).join(' ')}";
          
          // Parse authUrl to handle existing query parameters
          const authUrlObj = new URL(authUrl);
          authUrlObj.searchParams.set('response_type', responseType);
          authUrlObj.searchParams.set('client_id', clientId!);
          authUrlObj.searchParams.set('redirect_uri', redirectUri);
          authUrlObj.searchParams.set('scope', scopeStr);
          authUrlObj.searchParams.set('state', state);
          ${usePkce ? `
          authUrlObj.searchParams.set('code_challenge', codeChallenge);
          authUrlObj.searchParams.set('code_challenge_method', 'S256');` : ''}
          ${Object.keys(additionalAuthParams).length > 0 ? `
          // Add additional auth params
          ${Object.entries(additionalAuthParams).map(([k, v]) => 
            `authUrlObj.searchParams.set('${k}', '${v}');`
          ).join('\n          ')}` : ''}
          
          const targetUrl = authUrlObj.toString();
          console.error("Opening OAuth URL:", targetUrl);
          open(targetUrl);
      });

      try {
        const token = await p;
        globalTokens["${auth.id}"] = token;
        return {
            content: [{ type: "text", text: "Successfully logged in and stored token." }]
        };
      } catch (e: any) {
        return {
            content: [{ type: "text", text: "Login failed: " + e.message }]
        };
      }
  }
      `;
  }).join('\n')}

  switch (name) {
    ${project.tools.filter(t => t.enabled).map(tool => {
      const api = project.apis.find(a => a.id === tool.apiId);
      if (!api) return '';
      
      const auth = project.authSchemes.find(a => a.id === (tool.authId || api.defaultAuthId));
      
      let headersCode = `const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        ...${JSON.stringify(tool.headers || {})}
      };`;

      // Inject Auth
      let authConfigCode = 'undefined';
      
      if (auth) {
        if (auth.type === 'apiKey') {
          const envVar = `${auth.name.toUpperCase().replace(/\s+/g, '_')}_KEY`;
          headersCode += `\n      const apiKey = process.env.${envVar};
      if (!apiKey) throw new Error("Missing environment variable: ${envVar}");
      headers['${auth.config.headerName || 'Authorization'}'] = apiKey;`;
        } else if (auth.type === 'bearer') {
           const envVar = `${auth.name.toUpperCase().replace(/\s+/g, '_')}_TOKEN`;
           headersCode += `\n      const token = process.env.${envVar};
      if (!token) throw new Error("Missing environment variable: ${envVar}");
      headers['Authorization'] = \`Bearer \${token}\`;`;
        } else if (auth.type === 'oauth2') {
           const prefix = auth.name.toUpperCase().replace(/\s+/g, '_');
           
           if (auth.config.oauthFlow === 'interactive') {
               headersCode += `\n      
      let token = globalTokens["${auth.id}"];
      if (!token) {
          // Fallback to env var or error
          const envToken = process.env.${prefix}_ACCESS_TOKEN;
          if (envToken) {
              token = envToken;
          }
      }
      if (!token) throw new Error("No token available. Please run the 'login_${auth.name.toLowerCase().replace(/\s+/g, '_')}' tool first.");
      headers['Authorization'] = \`Bearer \${token}\`;`;
           } else {
               headersCode += `\n      const token = process.env.${prefix}_ACCESS_TOKEN;
      if (!token) throw new Error("Missing environment variable: ${prefix}_ACCESS_TOKEN");
      headers['Authorization'] = \`Bearer \${token}\`;`;
           }
           
           authConfigCode = `{
        authId: "${auth.id}",
        tokenUrl: "${auth.config.tokenUrl || ''}",
        refreshToken: process.env.${prefix}_REFRESH_TOKEN,
        clientId: process.env.${prefix}_CLIENT_ID,
        clientSecret: process.env.${prefix}_CLIENT_SECRET,
        tokenRequestFormat: "${auth.config.tokenRequestFormat || 'form'}",
        tokenAuthMethod: "${auth.config.tokenAuthMethod || 'body'}",
        additionalTokenParams: ${JSON.stringify(auth.config.additionalTokenParams || {})}
      }`;
        } else if (auth.type === 'basic') {
           const userVar = `${auth.name.toUpperCase().replace(/\s+/g, '_')}_USERNAME`;
           const passVar = `${auth.name.toUpperCase().replace(/\s+/g, '_')}_PASSWORD`;
           headersCode += `\n      const username = process.env.${userVar};
      const password = process.env.${passVar};
      if (!username || !password) throw new Error("Missing environment variables: ${userVar} or ${passVar}");
      const base64 = Buffer.from(\`\${username}:\${password}\`).toString('base64');
      headers['Authorization'] = \`Basic \${base64}\`;`;
        }
      }

      // Construct URL
      // Extract path parameters from the path template
      const pathParams = (tool.path.match(/\{([^}]+)\}/g) || []).map(p => p.slice(1, -1));
      
      let urlCode = `let url = "${api.baseUrl}${tool.path}";`;
      let argsHandling = `const requestArgs = { ...(args as any) };`;
      
      // Replace path parameters in URL and remove them from requestArgs
      if (pathParams.length > 0) {
         pathParams.forEach(param => {
           urlCode += `\n      if (requestArgs['${param}'] !== undefined) {
        url = url.replace('{${param}}', encodeURIComponent(String(requestArgs['${param}'])));
        delete requestArgs['${param}'];
      }`;
         });
      }

      return `
    case "${tool.name}": {
      ${headersCode}
      ${argsHandling}
      ${urlCode}
      
      const config = {
        method: "${tool.method}",
        url,
        headers,
        ${tool.method !== 'GET' ? 'data: requestArgs' : 'params: requestArgs'} 
      };
      
      const result = await makeRequest(config, ${authConfigCode});
      
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }`;
    }).join('\n')}
    
    default:
      throw new Error(\`Unknown tool: \${name}\`);
  }
});

async function run() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP Server running on stdio");
}

run().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});
`;
}

function getUsedAuthSchemes(project: Project): AuthScheme[] {
  const usedAuthIds = new Set<string>();
  
  project.tools.filter(t => t.enabled).forEach(tool => {
    if (tool.authId) {
      usedAuthIds.add(tool.authId);
    } else {
      const api = project.apis.find(a => a.id === tool.apiId);
      if (api && api.defaultAuthId) {
        usedAuthIds.add(api.defaultAuthId);
      }
    }
  });
  
  return project.authSchemes.filter(a => usedAuthIds.has(a.id));
}
